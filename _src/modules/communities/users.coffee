_ = require "lodash"
async = require "async"
mcprefix = "fc_u"

forums = null
communities = null

TABLENAME = "fcore"

class Users


	cleanup: (o, cb) ->
		console.log "RUNNING USERS.cleanup"
		@users {cid: o.cid, type: "all"}, (err, resp) =>
			if err
				cb(err)
				return
			if not resp.length
				cb(null, 0)
				return
			jobs = []
			_.each resp, (e) =>
				m =
					cid: o.cid
					id: e.id
					v: e.v

				jobs.push (callback) =>
					@delete(m, callback)
					return
				return
			async.parallelLimit jobs, 2, (err, results) ->
				if err
					console.log "Error: users 	cleanup async", err
					cb(err)
					return
				cb(null, true)
		return


	delete: (o, cb) ->
		if utils.validate(o, ["id","cid"], cb) is false
			return
		key = "#{mcprefix}#{o.cid}_#{o.id}"
		console.log "DELETING A USER NOW..."
		params =
			TableName: TABLENAME
			Key:
				pid:
					S: o.cid
				id:
					S: o.id
			Expected:
				v:
					ComparisonOperator: "EQ"
					AttributeValueList: [{"S": o.v}]
			ReturnValues: "ALL_OLD"
		dynamodb.deleteItem params, (err, resp) ->
			if err
				cb(err)
				return
		cb(null, true)
		return

	get: (o, cb) ->
		if utils.validate(o, ["id","cid"], cb) is false
			return
		key = "#{mcprefix}#{o.cid}_#{o.id}"
		memcached.get key, (err, resp) ->
			if err
				cb(err)
				return
			if resp isnt undefined
				# Cache hit
				cb(null, resp)
				return
			# Not cached

			# We need a consistent read as this will be stored in the cache.
			# When a read happens after a write if might not return the latest
			# value when not using consistent reads.
			params = 
				TableName: TABLENAME
				ConsistentRead: true
				Key:
					pid:
						S: o.cid
					id:
						S: o.id
			dynamodb.getItem params, (err, user) ->
				if err
					cb(err)
					return
				if _.isEmpty(user)
					utils.throwError(cb, "userNotFound")
					return
				_cacheAndReturn(user, cb)
				return
			return
		return 


	getUserIdFromExtId: (o, cb) ->
		if utils.validate(o, ["extid", "cid"], cb) is false
			return
		key = "#{mcprefix}#{o.cid}_extid_#{o.extid}"
		memcached.get key, (err, resp) ->
			if err
				cb(err)
				return
			if resp isnt undefined
				# Cache hit
				cb(null, resp)
				return
			# Not cached

			# We need a consistent read as this will be stored in the cache.
			# When a read happens after a write if might not return the latest
			# value when not using consistent reads.
			params = 
				TableName: TABLENAME
				ConsistentRead: true
				Key:
					pid:
						S: "#{o.cid}_extid"
					id:
						S: o.extid
			dynamodb.getItem params, (err, user) ->
				console.log err, user
				if err
					cb(err)
					return
				if _.isEmpty(user)
					utils.throwError(cb, "externalIdNotFound")
					return
				
				data = utils.dynamoConvertItem(user)
				data = utils.userExtIdPrepare(data)
				cb(null, data)
				return
			return
		return


	# Insert a new user
	#
	# Parameters:
	#
	# * `id` (String) UserID (optional) - will be autogenerated
	# * `p` (Object) Properties.
	#
	insert: (o, cb) ->
		# if `id` is not supplied we generate an id.
		_preCheckUserId o, (err, o) =>
			if err
				cb(err)
				return
			keystocheck = ["cid","p","id"]
			if o.extid?
				keystocheck.push("extid")
			if utils.validate(o, keystocheck, cb) is false
				return
			@preCheckUserExtId o, (err, o) ->
				if err
					cb(err)
					return
				# Make sure this community exists
				communities.get {cid:o.cid}, (err, resp) ->
					if err
						cb(err)
						return
					if not resp.id?
						cb(null,{})
						return
					# Get a new id
					utils.getTimestamp (err, ts) ->
						if err
							cb(err)
							return
						params =
							TableName: TABLENAME
							Item:
								pid:
									S: o.cid
								id:
									S: o.id
								p:
									S: utils.storeProps(o.p)
								c:
									S: ts
								v:
									S: ts
							Expected:
								pid:
									ComparisonOperator: "NULL"
								id:
									ComparisonOperator: "NULL"
						if o.extid?
							params.Item.extid =
								S: o.extid
						dynamodb.putItem params, (err, data) ->
							if err
								if err.message is "The conditional request failed"
									utils.throwError(cb, "userExists")
									return
								cb(err)
								return
							if o.extid?
								_setExtId o.cid, null, o.extid, o.id, (err, resp) ->
									if err
										cb(err)
										return
									_cacheAndReturn(params, cb)
									return
							else
								_cacheAndReturn(params, cb)
							return
						return
					return
				return
			return
		return

	# Messages by User
	#
	# Returns a list of all messages written by the user
	#
	# Will return 100 Messages. If 100 are returned there might be more.  
	# User the `esk` URL Parameter with the 100th id of the result to get the next 100
	#
	# Parameters:
	#
	# * `id` (String) User Id
	# * `cid` (String) Community Id
	#
	# URL Parameters:
	#
	# * `esk` (String) Exclusive Start Key: 
	#
	messagesByUser: (o, cb) ->
		if utils.validate(o, ["cid","id"], cb) is false
			return
		params = 
			TableName: TABLENAME
			Limit: 100
			AttributesToGet: ["id", "fid", "tid"]
			KeyConditions:
				pid:
					ComparisonOperator: "EQ"
					AttributeValueList: [
						S: "#{o.cid}_#{o.id}"
					]
			ScanIndexForward: false
		if o.esk
			params.ExclusiveStartKey =
				"id":
					S: o.esk
				"pid":
					S: "#{o.cid}_#{o.id}"
		utils.singlequery params, (err, resp) =>
			if err
				cb(err)
				return
			cb(null, utils.userQueryPrepare(resp))
			return
		return

	# This will check an extid for a user object
	# If it does not exist it will return the object
	# If it does exist alrdy it throws an error
	#
	preCheckUserExtId: (o, cb) ->
		if not o.extid?
			cb(null, o)
			return
		@getUserIdFromExtId o, (err, resp) ->
			if err
				if err.name is "externalIdNotFound"
					cb(null, o)
				else
					cb(err)
				return
			utils.throwError(cb, "externalIdNotUnique")		
			return
		return

	# Remove author
	#
	# *Called when a message is deleted*
	#
	# Remove a simple association between a user and a message. 
	# Used to query all messages by an author.
	#
	# Parameters:
	# 
	# * `id` (String) User Id
	# * `cid` (String) Community Id
	# * `mid` (String) Message Id
	removeAuthor: (o, cb) ->
		params =
			TableName: TABLENAME
			Key:
				pid:
					S: "#{o.cid}_#{o.a.toLowerCase()}"
				id: 
					S: o.id
		dynamodb.deleteItem params, (err, resp) ->
			if err
				cb(err)
				return
			cb(null, true)
			return
		return			

	# Set author
	#
	# *Called when a message is inserted*
	#
	# Store a simple association between a user and a message. 
	# Used to query all messages by an author.
	#
	# Parameters:
	# 
	# * `id` (String) User Id
	# * `cid` (String) Community Id
	# * `mid` (String) Message Id

	setAuthor: (o, cb) ->
		params =
			TableName: TABLENAME
			Item:
				pid:
					S: "#{o.cid}_#{o.id}"
				id: 
					S: o.mid
				fid:
					S: o.fid
				tid:
					S: o.tid
		dynamodb.putItem params, (err, data) ->
			if err
				cb(err)
				return
			cb(null, true)
			return
		return


	# Update a user
	#
	# Parameters:
	#
	# * `id` (String) User Id
	# * `cid` (String) Community Id
	# * `p` (Object) Properties. Must include at least a `tpid` (String) key.
	# * `v` (Number) The current version number must be supplied for a successful update.
	#
	update: (o, cb) ->
		keystocheck = ["cid","id","p","v"]
		if o.extid?
			keystocheck.push("extid")
		if utils.validate(o, keystocheck, cb) is false
			return
		@get o, (err, user) =>
			if err
				cb(err)
				return
			if not user.id?
				cb(null, {})
				return

			o.p = utils.cleanProps(user.p, o.p)
			if utils.validate(o, ["p"], cb) is false
				return

			if user.extid and o.extid and user.extid is o.extid
				console.log "extid did not change. REMOVED FROM OBJECT"
				o = _.omit(o, "extid")

			# Nothing changed. Bail out and return the current item.
			if _.isEqual(user.p, o.p) and (o.extid is undefined or (o.extid is null and not user.extid)) 
				cb(null, user)
				return

			# We need to call a check for extid and see if 
			#
			# * The extid changed
			# * If it changed if it is valid and does not exist yet for another user
			#

			@preCheckUserExtId o, (err, o) ->
				if err
					cb(err)
					return




				# Make sure this community exists
				communities.get {cid: o.cid}, (err, resp) ->
					if err
						cb(err)
						return
					if not resp.id?
						cb(null,{})
						return
					utils.getTimestamp (err, ts) ->
						if err
							cb(err)
							return
						params =
							TableName: TABLENAME
							Key:
								pid:
									S: o.cid
								id:
									S: o.id
							AttributeUpdates:
								p:
									Value:
										S: JSON.stringify(o.p)
									Action: "PUT"
								v:
									Value:
										S: ts
									Action: "PUT"
							Expected:
								v:
									ComparisonOperator: "EQ"
									AttributeValueList: [{"S": o.v}]

							ReturnValues: "ALL_NEW"
						# Add the extid to the update
						if o.extid
							params.AttributeUpdates.extid =
								Value:
									S: o.extid
								Action: "PUT"
						if o.extid is null
							params.AttributeUpdates.extid =
								Action: "DELETE"
						dynamodb.updateItem params, (err, data) ->
							if err
								if err.message is "The conditional request failed"
									utils.throwError(cb, "invalidVersion")
									return
								cb(err)
								return
							if o.extid?
								oldextid = user.extid or null
								_setExtId o.cid, oldextid, o.extid, o.id, (err, resp) ->
									if err
										cb(err)
										return
									_cacheAndReturn(data, cb)
									return
							else
								_cacheAndReturn(data, cb)
							return
						return
					return
				return
			return
		return

	
	# Get hte Users of a community
	#
	# Parameters:
	# 
	# * `cid` (String) Community id
	# * `esk` (optional, string, `Mhx123abc`) ... Exclusive Start Key  
    
	#
	users: (o, cb) ->
		o.type = o.type or "id"
		if utils.validate(o, ["cid","type"], cb) is false
			return
		params =
			TableName: TABLENAME
			AttributesToGet: o.type
			Limit: 100
			KeyConditions:
				pid:
					ComparisonOperator: "EQ"
					AttributeValueList: [
						S: o.cid
					]
		if o.esk
			params.ExclusiveStartKey =
				"id":
					S: o.esk
				"pid":
					S: o.cid

		utils.singlequery params, (err, resp) ->
			if err
				cb(err)
				return
			cb(null, utils.userQueryPrepare(resp))
			return
		return


	verify: (o, cb) ->
		# If there is not user to check just return
		if not o.a?
			cb(null, {})
			return
		if utils.validate(o, ["fid", "a"], cb) is false
			return
		forums.get o, (err, forum) =>
			if err
				cb(err)
				return
			if not forum.id?
				utils.throwError(cb, "forumNotFound")
				return
			# The forum exists. Now check the user
			o.id = o.a
			o.cid = forum.cid
			@get o, cb
			return
		return


_cacheAndReturn = (data, cb) ->
	data = utils.dynamoConvertItem(data)
	key = "#{mcprefix}#{data.pid}_#{data.id}"
	data = utils.userPrepare(data)
	memcached.set key, data, 86400, ->
	cb(null, data)
	return


_deleteExtId = (cid, extid, cb) ->
	if not extid?
		cb(null, true)
		return
	params =
		TableName: TABLENAME
		Key:
			pid:
				S: "#{cid}_extid"
			id: 
				S: extid
	dynamodb.deleteItem(params, cb)
	return


_preCheckUserId = (o, cb) ->
	if o.id?
		cb(null, o)
		return
	# generate a new userid
	utils.getTimestamp (err, ts) ->
		if err
			cb(err)
			return
		o.id = ts + utils.getRandomInt(10,100)
		cb(null, o)
		return
	return


# Set External Id of a User
#
_setExtId = (cid, oldextid, newextid, userid, cb) ->

	if oldextid
		_deleteExtId cid, oldextid, (err, resp) ->
			if err
				cb(err)
				return
			_setNewExtId(cid, newextid, userid, cb)	
			return
		return
	_setNewExtId(cid, newextid, userid, cb)	
	return


_setNewExtId = (cid, newextid, userid, cb) ->
	params =
		TableName: TABLENAME
		Item:
			pid:
				S: "#{cid}_extid"
			id: 
				S: newextid
			userid:
				S: userid
	dynamodb.putItem(params, cb)
	return


_updCheckExtId = () ->

	return

module.exports = new Users()

forums = require "../forums/forums"
communities = require "./communities"