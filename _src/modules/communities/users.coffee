_ = require "lodash"
async = require "async"
mcprefix = "fc_u"

forums = null
communities = null

TABLENAME = "fcore"

class Users


	cleanup: (o, cb) ->
		console.log "RUNNING USERS.cleanup"
		@users {cid: o.cid, type: "all"}, (err, resp) =>
			if err
				cb(err)
				return
			if not resp.length
				cb(null, 0)
				return
			jobs = []
			_.each resp, (e) =>
				m =
					cid: o.cid
					id: e.id
					v: e.v

				jobs.push (callback) =>
					@delete(m, callback)
					return
				return
			async.parallelLimit jobs, 2, (err, results) ->
				if err
					console.log "Error: users 	cleanup async", err
					cb(err)
					return
				cb(null, true)
		return


	get: (o, cb) ->
		if utils.validate(o, ["id","cid"], cb) is false
			return
		key = "#{mcprefix}#{o.cid}_#{o.id}"
		memcached.get key, (err, resp) ->
			if err
				cb(err)
				return
			if resp isnt undefined
				# Cache hit
				cb(null, resp)
				return
			# Get the item from DB
			query = 
				name: "get user by id"
				text: "SELECT id, cid, c, v, p, extid FROM u WHERE id = $1 and cid = $2"
				values: [
					o.id
					o.cid
				]
			utils.pgqry query, (err, resp) ->
				if err
					cb(err)
					return
				# Make sure the supplied pid is the same
				if not resp.rows.length 
					utils.throwError(cb, "userNotFound")
					return

				_cacheAndReturn(resp.rows[0], cb)
				return
			return
		return 


	getUserIdFromExtId: (o, cb) ->
		if utils.validate(o, ["extid", "cid"], cb) is false
			return
		key = "#{mcprefix}#{o.cid}_extid_#{o.extid}"
		memcached.get key, (err, resp) ->
			if err
				cb(err)
				return
			if resp isnt undefined
				# Cache hit
				cb(null, resp)
				return
			# Get the item from DB
			query = 
				name: "get forum by id"
				text: "SELECT id, cid, c, v, p, extid FROM u WHERE extid = $1 and cid = $2"
				values: [
					o.extid
					o.cid
				]
			utils.pgqry query, (err, data) ->
				if err
					cb(err)
					return
				if not data.rows.length 
					utils.throwError(cb, "externalIdNotFound")
					return

				_cacheAndReturn(data.rows[0], cb)
				return
			return
		return


	# Insert a new user
	#
	# Parameters:
	#
	# * `id` (String) UserID (optional) - will be autogenerated
	# * `p` (Object) Properties.
	#
	insert: (o, cb) ->
		that = @
		# if `id` is not supplied we generate an id.
		_preCheckUserId o, (err, o) =>
			if err
				cb(err)
				return
			keystocheck = ["cid","p","id"]
			if o.extid?
				keystocheck.push("extid")
			if utils.validate(o, keystocheck, cb) is false
				return
			@preCheckUserExtId o, (err, o) ->
				if err
					cb(err)
					return
				# Make sure this community exists
				communities.get {cid:o.cid}, (err, resp) ->
					if err
						cb(err)
						return

					query =
						name: "insert user"
						text: "INSERT INTO u (id, cid, p, extid) VALUES ($1, $2, $3, $4) RETURNING id, cid, c, v, p, extid;"
						values: [
							o.id,
							o.cid
							utils.storeProps(o.p)
							o.extid or null
						]
					utils.pgqry query, (err, resp) ->
						if err
							if err.detail.indexOf("already exists") > -1
								utils.throwError(cb, "userExists")
								return
							cb(err)
							return
						if resp.rowCount isnt 1
							utils.throwError(cb, "insertFailed")
							return
						_cacheAndReturn(resp.rows[0], cb)
						return
					return
				return
			return
		return

	# Messages by User
	#
	# Returns a list of all messages written by the user
	#
	# Will return 100 Messages. If 100 are returned there might be more.  
	# User the `esk` URL Parameter with the 100th id of the result to get the next 100
	#
	# Parameters:
	#
	# * `id` (String) User Id
	# * `cid` (String) Community Id
	#
	# URL Parameters:
	#
	# * `esk` (String) Exclusive Start Key: 
	#
	messagesByUser: (o, cb) ->
		if utils.validate(o, ["cid","id"], cb) is false
			return
		params = 
			TableName: TABLENAME
			Limit: 100
			AttributesToGet: ["id", "fid", "tid"]
			KeyConditions:
				pid:
					ComparisonOperator: "EQ"
					AttributeValueList: [
						S: "#{o.cid}_#{o.id}"
					]
			ScanIndexForward: false
		if o.esk
			params.ExclusiveStartKey =
				"id":
					S: o.esk
				"pid":
					S: "#{o.cid}_#{o.id}"
		utils.singlequery params, (err, resp) =>
			if err
				cb(err)
				return
			cb(null, utils.userQueryPrepare(resp))
			return
		return

	# This will check an extid for a user object
	# If it does not exist it will return the object
	# If it does exist alrdy it throws an error
	#
	preCheckUserExtId: (o, cb) ->
		if not o.extid?
			cb(null, o)
			return
		@getUserIdFromExtId o, (err, resp) ->
			if err
				if err.name is "externalIdNotFound"
					cb(null, o)
				else
					cb(err)
				return
			utils.throwError(cb, "externalIdNotUnique")		
			return
		return

	# Remove author
	#
	# *Called when a message is deleted*
	#
	# Remove a simple association between a user and a message. 
	# Used to query all messages by an author.
	#
	# Parameters:
	# 
	# * `id` (String) User Id
	# * `cid` (String) Community Id
	# * `mid` (String) Message Id
	removeAuthor: (o, cb) ->
		query =
			name: "removeAuthor"
			text: "DELETE FROM authors WHERE cid = $1 and uid = $2 AND mid = $3"
			values: [
				o.cid
				o.id
				o.mid
			]
		utils.pgqry query, (err, resp) ->
			if err
				cb(err)
				return
			cb(null, true)
			return
		return			

	# Set author
	#
	# *Called when a message is inserted*
	#
	# Store a simple association between a user and a message. 
	# Used to query all messages by an author.
	#
	# Parameters:
	# 
	# * `id` (String) User Id
	# * `cid` (String) Community Id
	# * `mid` (String) Message Id

	setAuthor: (o, cb) ->
		query =
			name: "setAuthor"
			text: "INSERT INTO authors (cid, uid, mid, fid, tid) VALUES ($1, $2, $3, $4, $5)"
			values: [
				o.cid
				o.id
				o.mid
				o.fid
				o.tid
			]
		utils.pgqry query, (err, data) ->
			if err
				cb(err)
				return
			cb(null, true)
			return
		return


	# Update a user
	#
	# Parameters:
	#
	# * `id` (String) User Id
	# * `cid` (String) Community Id
	# * `p` (Object) Properties. Must include at least a `tpid` (String) key.
	# * `v` (Number) The current version number must be supplied for a successful update.
	#
	update: (o, cb) ->
		keystocheck = ["cid","id","p","v"]
		if o.extid?
			keystocheck.push("extid")
		if utils.validate(o, keystocheck, cb) is false
			return
		@get o, (err, user) =>
			if err
				cb(err)
				return
				
			if user.v isnt o.v
				utils.throwError(cb, "invalidVersion")
				return

			o.p = utils.cleanProps(user.p, o.p)
			if utils.validate(o, ["p"], cb) is false
				return

			# Nothing changed. Bail out and return the current item.
			if _.isEqual(user.p, o.p) and o.extid is user.extid
				cb(null, user)
				return

			# We need to call a check for extid and see if 
			#
			# * The extid changed
			# * If it changed if it is valid and does not exist yet for another user
			#

			@preCheckUserExtId o, (err, o) ->
				if err
					cb(err)
					return

				# Make sure this community exists
				communities.get {cid: o.cid}, (err, resp) ->
					if err
						cb(err)
						return
					
					query =
						name: "user update with extid"
						text: "UPDATE u SET p = $1, v = base36_timestamp(), extid = $2 WHERE id = $3 and cid = $4 and v = $5 RETURNING id, cid, c, v, p, extid;"
						values: [
							JSON.stringify(o.p)
							o.extid
							o.id
							o.cid
							o.v
						]

					utils.pgqry query, (err, resp) ->
						if err
							cb(err)
							return
						if resp.rowCount is 0
							utils.throwError(cb, "invalidVersion")
							return
						_cacheAndReturn(resp.rows[0], cb)
						return
					return
				return
			return
		return

	
	# Get the Users of a community
	#
	# Parameters:
	# 
    # + cid (required, string, `123456_hxfu1234`) ... The id of the community.
    # + type (optional, string, `id`) ... Either `id`, `p` or `all` to return just the id, properties or all. Default: `id`
    # + esk (optional, string, `someusername`) ... Exclusive Start Key
	#
	users: (o, cb) ->
		tovalidate = ["cid","type"]
		o.type = o.type or "id"
		# Turn the `esk` key into an user id
		o.id = o.esk or ""
		if o.id
			tovalidate.push("id")
		if utils.validate(o, tovalidate, cb) is false
			return
		query =
			name: "users of community #{o.type.join(",")}"
			text: "SELECT #{o.type.join(",")} FROM u WHERE cid = $1 and id > $2 LIMIT 100"
			values: [
				o.cid
				o.id
			]
		utils.pgqry query, (err, resp) ->
			if err
				cb(err)
				return
			cb(null, utils.userQueryPrepare(resp.rows))
			return
		return


	verify: (o, cb) ->
		# If there is not user to check just return
		if not o.a?
			cb(null, {})
			return
		if utils.validate(o, ["fid", "a"], cb) is false
			return
		forums.get o, (err, forum) =>
			if err
				cb(err)
				return
			if not forum.id?
				utils.throwError(cb, "forumNotFound")
				return
			# The forum exists. Now check the user
			o.id = o.a
			o.cid = forum.cid
			@get o, cb
			return
		return


_cacheAndReturn = (data, cb) ->
	key = "#{mcprefix}#{data.cid}_#{data.id}"
	data = utils.respPrepare(data)
	memcached.set key, data, 86400, ->
	cb(null, data)
	return


_preCheckUserId = (o, cb) ->
	if o.id?
		cb(null, o)
		return
	# generate a new userid
	utils.getTimestamp (err, ts) ->
		if err
			cb(err)
			return
		o.id = ts + utils.getRandomInt(10,100)
		cb(null, o)
		return
	return


module.exports = new Users()

forums = require "../forums/forums"
communities = require "./communities"